"""
Author: Matthias Grajewski (grajewski@fh-aachen.de) and Luis Hasenauer
This file is part of faultapprox-python (https://github.com/mgrajewski/faultapprox-python)
"""

from warnings import warn

import numpy as np
import numpy.typing as npt
from scipy.linalg import norm
from typing import Tuple

from computeClassification import compute_classification
from entities.Entities import FaultApproxParameters, ProblemDescr


def start_pairs(points_left: npt.ArrayLike, points_right: npt.ArrayLike,
                classes_left: npt.ArrayLike, classes_right: npt.ArrayLike,
                i_class: int, j_class: int, problem_descr: ProblemDescr) -> \
        Tuple[npt.ArrayLike, npt.ArrayLike, npt.ArrayLike]:
    """This function creates pairs of points near a fault line, one of which is in class i_class and the other in
    class j_class. These point pairs and their respective classes are stored in points_succeeded and
    class_points_succeeded. It serves for finding starting values for bisection.
    The function requires an initial guess for the point pairs given in points_on_curve and points_besides_curve.
    If a point in PointsLeft is in class i_class and its counterpart (aka the point at the same position in
    points_right) is in class j_class, fine. If not, we consider two cases: Either both points belong to the same class
    i_class or j_class. Then, we mirror these points in points_right at the respective points in points_left and
    continue. If this does not lead to a suitable point pair, we enlarge the perturbation for points_right and continue
    up to max_num_trials times.
    As second case, it may happen that one point of the pair neither belongs to i_class or j_class but to another class.
    This may happen if the fault line is about to leave the domain or if three or more classes meet on in one point.
    Then, we scatter along the normal to the point on the curve in both directions. If one of these points leads to a
    valid pair of points, fine. If not, we give up for that point pair.

    Args:
        points_left (npt.ArrayLike):
            Points near a curve approximating some component of a fault line (usually generated by subdividing a line
            segment or polynomial extrapolation). Shape: (n_points, dim)
        points_right (npt.ArrayLike):
            Points near a curve, ideally on the other side of the curve as points_left. Shape: (n_points, ndim)
        classes_left (npt.ArrayLike):
            class index of the points in points_left. Shape: (n_points,)
        classes_right (npt.ArrayLike):
            class index of the points in points_right. Shape: (n_points,)
        i_class (int):
            indices of the classes the fault line is in between
        j_class (int):
            indices of the classes the fault line is in between
        problem_descr (ProblemDescr):
            Object containing all problem-relevant parameters. We refer to its documentation in Entities.py for details.

    Returns:
        npt.ArrayLike: point_pairs
        npt.ArrayLike: succeeded
        npt.ArrayLike: class_point_pairs

    """

    # maximum number of trials in case of failure mode 1 (both points belong to the same class)
    max_num_trials = 3

    eps = 1e-10

    # dimension of the data
    n_points, n_dim = points_left.shape

    # array of valid point pairs
    point_pairs = np.zeros((n_points, 2 * n_dim), dtype=float)

    # corresponding classes
    class_point_pairs = np.zeros((n_points, 2), dtype=int)

    # true, if for the corresponding point pair a valid starting pair could be found (initially false)
    points_old_even = points_left.copy()

    # Finding valid pairs may fail due to presence of a third class very near the fault line. However, this may turn out
    # only during the first phase and cannot be derived from the initial choice of points. We mark all points where a
    # third class occurred during the first phase.
    third_class_involved = np.zeros(n_points, dtype=bool)

    points_right_orig = points_right.copy()

    # first pass: consider case both classes are the same

    # If a point is in class i_class and its counterpart (aka the point at the same position in
    # points_right) is in class j_class or vice versa: search of point pair succeeded.
    succeeded = np.logical_and(classes_left == i_class, classes_right == j_class) | \
        np.logical_and(classes_left == j_class, classes_right == i_class)

    # We mark all points where at some point in the algorithm a third class has been involved: It may happen that
    # initially, a third class has been involved, but at the current stage, the points of the pair belong to the
    # same class. This case requires a different treatment than the case where the both points of the starting pair
    # just belong to i_class or j_class. If initially a third class has been involved, but by coincide, a suitable
    # point pair has been found, then this pair is marked as succeeded and is excluded from any further treatment
    # anyway.
    third_class_involved = third_class_involved | \
        np.logical_and(classes_left != i_class, classes_left != j_class) | \
        np.logical_and(classes_right != i_class, classes_right != j_class)
    # If still_the_same_class, both points belong to the same class i_class or j_class. Only in this case, the
    # expansive treatment in the first part of this algorithm makes sense.
    still_the_same_class = (classes_left == classes_right) & ((classes_left == i_class) | (classes_left == j_class))

    point_pairs[succeeded] = np.concatenate((points_left[succeeded], points_right[succeeded]), axis=1)
    class_point_pairs[succeeded] = np.array([classes_left[succeeded], classes_right[succeeded]]).T

    # If for all points class change takes place: finish, if not: try opposite direction for remaining points.
    if np.any(still_the_same_class):
        for j in range(max_num_trials):

            # Try opposite direction: mirror on line, unless one leaves the domain.

            # This is to choose optimal point pairs only
            points_old_odd = points_right.copy()

            points_right[still_the_same_class] = 2 * points_left[still_the_same_class] - points_right[
                still_the_same_class]

            # restrict the points to the domain
            points_right[still_the_same_class, 0] = np.minimum(
                np.maximum(problem_descr.x_min[0] + eps, points_right[still_the_same_class, 0]),
                problem_descr.x_max[0] - eps)
            points_right[still_the_same_class, 1] = np.minimum(
                np.maximum(problem_descr.x_min[1] + eps, points_right[still_the_same_class, 1]),
                problem_descr.x_max[1] - eps)
            classes_right[still_the_same_class] = compute_classification(points_right[still_the_same_class],
                                                                         problem_descr)

            succeeded_now = np.logical_or((classes_left == i_class) & (classes_right == j_class),
                                          (classes_left == j_class) & (classes_right == i_class)) & ~succeeded

            still_the_same_class = (classes_left == classes_right) & (
                    (classes_left == i_class) | (classes_left == j_class))
            point_pairs[succeeded_now] = np.concatenate(
                (points_old_even[succeeded_now], points_right[succeeded_now]), axis=1)
            class_point_pairs[succeeded_now] = np.array([classes_left[succeeded_now], classes_right[succeeded_now]]).T
            succeeded = succeeded | succeeded_now

            third_class_involved = third_class_involved | \
                np.logical_and(classes_left != i_class, classes_left != j_class) | \
                np.logical_and(classes_right != i_class, classes_right != j_class)

            # If for all points class change between i_class and j_class takes place: finish, if not: double distance to
            # straight line.
            if not np.any(still_the_same_class):
                break

            # points_odd
            points_old_even = points_right.copy()

            # If still points are unfinished: go into the opposite direction.
            points_right[still_the_same_class] = 3 * points_left[still_the_same_class] - 2 * points_right[
                still_the_same_class]
            points_right[still_the_same_class, 0] = np.minimum(
                np.maximum(problem_descr.x_min[0] + eps, points_right[still_the_same_class, 0]),
                problem_descr.x_max[0] - eps)
            points_right[still_the_same_class, 1] = np.minimum(
                np.maximum(problem_descr.x_min[1] + eps, points_right[still_the_same_class, 1]),
                problem_descr.x_max[1] - eps)
            classes_right[still_the_same_class] = compute_classification(points_right[still_the_same_class],
                                                                         problem_descr)

            succeeded_now = np.logical_or((classes_left == i_class) & (classes_right == j_class),
                                          (classes_left == j_class) & (classes_right == i_class)) & ~succeeded

            still_the_same_class = (classes_left == classes_right) & (
                    (classes_left == i_class) | (classes_left == j_class))
            point_pairs[succeeded_now] = np.concatenate(
                (points_old_odd[succeeded_now], points_right[succeeded_now]), axis=1)
            class_point_pairs[succeeded_now] = np.array([classes_left[succeeded_now], classes_right[succeeded_now]]).T
            succeeded = np.logical_or(succeeded, succeeded_now)
            third_class_involved = third_class_involved | \
                np.logical_and(classes_left != i_class, classes_left != j_class) | \
                np.logical_and(classes_right != i_class, classes_right != j_class)

            if not np.any(still_the_same_class):
                break

    # If there are any points still unfinished due to a third class involved, we try scattering around the midpoint of
    # the original point_pair along the approximate normal.
    idx_failed2 = ~succeeded & third_class_involved
    if np.any(idx_failed2):

        # Go back to the original points (points_left has never been touched).
        points_right[idx_failed2] = points_right_orig[idx_failed2]
        i_idx_vec = np.flatnonzero(idx_failed2 & ~succeeded)

        # Scatter around the normal to the points.
        pars = np.array([[-0.8, -0.4, -0.2, 0, 0.2, 0.4, 0.8]])
        par_size = pars.shape[1]
        aux_left = points_left[idx_failed2]
        aux_right = points_right[idx_failed2]
        normals = aux_left - aux_right
        aux_points = np.zeros((par_size * aux_left.shape[0], n_dim))
        for i_loc in range(aux_left.shape[0]):
            aux_points[i_loc * par_size:(i_loc + 1) * par_size] = 0.5 * (
                    aux_left[i_loc] + aux_right[i_loc]) + pars.T * normals[i_loc]

        # indices of the auxiliary points inside the domain
        idx_inside = np.all((aux_points >= problem_descr.x_min) & (aux_points <= problem_descr.x_max), axis=1)

        # We classify only the points inside the domain.
        class_aux = -np.ones((aux_points.shape[0]))
        class_aux[idx_inside] = compute_classification(aux_points[idx_inside], problem_descr)
        for i_loc in range(aux_left.shape[0]):
            class_aux_loc = class_aux[i_loc * par_size:(i_loc + 1) * par_size]
            aux_points_loc = aux_points[i_loc * par_size:(i_loc + 1) * par_size]

            # There is a suitable point pair.
            if np.any(class_aux_loc == i_class) and np.any(class_aux_loc == j_class):
                # This is not optimal: We just take one suitable pair and not the one with the nearest points if there
                # are more than one.
                idx_i_class_min = np.flatnonzero(class_aux_loc == i_class)[0]
                idx_j_class_min = np.flatnonzero(class_aux_loc == j_class)[0]

                idx_i_class_max = np.flatnonzero(class_aux_loc == i_class)[-1]
                idx_j_class_max = np.flatnonzero(class_aux_loc == j_class)[-1]

                # Find points in the Aux vector with the correct classes.
                if idx_i_class_max < idx_j_class_min:
                    idx_i_class = idx_i_class_max
                    idx_j_class = idx_j_class_min
                else:
                    idx_i_class = idx_i_class_min
                    idx_j_class = idx_j_class_max

                point_pairs[i_idx_vec[i_loc]] = np.concatenate(
                    (aux_points_loc[idx_i_class], aux_points_loc[idx_j_class]), axis=0)
                class_point_pairs[i_idx_vec[i_loc]] = np.array([i_class, j_class])
                succeeded[i_idx_vec[i_loc]] = 1
    return point_pairs, succeeded, class_point_pairs


def triplets_by_bisection(points_left_start: npt.ArrayLike, points_right_start: npt.ArrayLike,
                          classes_left: npt.ArrayLike, classes_right: npt.ArrayLike,
                          problem_descr: ProblemDescr, fault_approx_pars: FaultApproxParameters) -> \
        Tuple[npt.ArrayLike, npt.ArrayLike, npt.ArrayLike]:
    """
    This function computes two arrays of points points_left and points_right near the fault line between classes stored
    in classes_left and classes_right by bisection.
    The points in points_left, points_right belong to the classes classes_left and classes_right, respectively. It
    assumes two arrays of initial points points_left_start and points_right_start with points belonging to the classes
    stored in classes_left and classes_right, resp.
    If the search for a certain point i was finished successfully, we set finished[i] = True, otherwise False. In the
    latter case, the corresponding entries in points_left and points_right are dummies only, so do not use them.
    If during bisection, a third class occurs, we stop the computation of that point pair and proceed. We set
    finished[i] = False in this case.

    Args:
        points_left_start (npt.ArrayLike):
            points left from a true fault line. Shape: (npoints, ndim)
        points_right_start (npt.ArrayLike):
            points right from a true fault line, counterpart to points_left_start. Shape: (npoints, ndim)
        classes_left (npt.ArrayLike):
            classes of the points in points_left_start (the classes do not need to be the same for all initial points).
            Shape: (npoints,)
        classes_right (npt.ArrayLike):
            classes of the points in points_right_start (the classes do not need to be the same for all initial points).
            Shape: (npoints,)
        problem_descr (ProblemDescr):
            Object containing all problem-relevant parameters. We refer to its documentation in Entities.py for details.
        fault_approx_pars (FaultApproxParameters):
            Object containing all parameters relevant for the fault detection algorithm. We refer to its documentation
            in Entities.py for details.

    Returns:
        npt.ArrayLike: points_left
        npt.ArrayLike: points_right
        npt.ArrayLike: finished

    """

    num_points, ndim = points_left_start.shape

    assert points_right_start.shape[0] == num_points, \
        'The arrays points_left_start and points_right_start contain a different number of points.'

    # stopping criterion for bisection algorithm
    abstol_bisection = fault_approx_pars.abstol_bisection

    # maximum number of bisection iterations
    max_iter_bisection = fault_approx_pars.max_iter_bisection

    finished = np.zeros(num_points, dtype=bool)
    finished_aux = np.zeros(num_points, dtype=bool)
    points_mid = np.zeros((num_points, ndim), dtype=float)
    classes_mid = np.zeros(num_points, dtype=int)

    points_left = np.zeros((num_points, ndim), dtype=float)
    points_right = np.zeros((num_points, ndim), dtype=float)

    other_class = False

    iiter = 1

    while iiter <= max_iter_bisection:

        dist = norm((points_left_start - points_right_start).T, axis=0)
        finished = (dist < 2*abstol_bisection)
        finished_aux = np.logical_or(finished, finished_aux)

        # Add points to the list of surface points and break. Note that both points are in different classes.
        if np.all(finished_aux):
            points_left = points_left_start
            points_right = points_right_start

            if other_class:
                msg = 'Bisection for at least one point in triplets_by_bisection failed due to a third class.'
                warn(msg)

            return points_left, points_right, finished

        else:
            finished_aux_inv = np.logical_not(finished_aux)
            points_mid[finished_aux_inv] = 0.5 * (points_left_start[finished_aux_inv] +
                                                  points_right_start[finished_aux_inv])

            classes_mid[finished_aux_inv] = compute_classification(points_mid[finished_aux_inv], problem_descr)

            # same class as left point: fault line is on the right
            idx_left = (finished_aux_inv & (classes_mid == classes_left))
            points_left_start[idx_left] = points_mid[idx_left]

            idx_right = (finished_aux_inv & (classes_mid == classes_right))
            points_right_start[idx_right] = points_mid[idx_right]

            # Sort out all points where a third class is involved.
            idx_another_class = finished_aux_inv & (classes_left != classes_mid) & (classes_mid != classes_right)
            if np.any(idx_another_class):
                other_class = True
            finished_aux[idx_another_class] = True

        iiter += 1

    if not np.all(finished):
        warn_message = f"Bisection for at least one point in triplets_by_bisection failed, consider enlarging \
                       max_iter_bisection."
        warn(warn_message)

    return points_left, points_right, finished


def single_triplet_by_bisection(point_left: npt.ArrayLike, point_right: npt.ArrayLike, class_left: int,
                                class_right: int, problem_descr: ProblemDescr,
                                fault_approx_pars: FaultApproxParameters) -> \
        Tuple[npt.ArrayLike, npt.ArrayLike, bool]:
    """
    This function returns two points point_left and point_right near the fault line between the classes class_left and
    class_right by bisection which belong to class class_left and class_right.

    This function assumes two initial points point_left and point_right which belong to class class_left and
    class_right, respectively.
    If the computation was finished successfully, this is indicated by finished = true, otherwise false.
    In the latter case, the returned points point_left and point_right are dummies only, so do not use them.

    Args:
        point_left (npt.ArrayLike):
            The first of the two points. Shape: (ndim)
        point_right (npt.ArrayLike)
            The other of the two points. Shape: (ndim)
        class_left (int)
            Class index of point_left.
        class_right (int)
            Class index of point_right.
        problem_descr (ProblemDescr):
            Object containing all problem-relevant parameters. We refer to its documentation in Entities.py for details.
        fault_approx_pars (FaultApproxParameters):
            Object containing all parameters relevant for the fault detection algorithm. We refer to its documentation
            in Entities.py for details.

    Returns:
        Tuple[npt.ArrayLike, npt.ArrayLike, npt.ArrayLike, bool]: point_left_final, point_right_final, finished.
    """

    # stopping criterion for bisection algorithm
    abstol_bisection = fault_approx_pars.abstol_bisection

    # maximum number of bisection iterations
    max_iter_bisection = fault_approx_pars.max_iter_bisection

    finished = False

    # norm of euclidean distance between left and right point
    norm_dist = norm(point_left - point_right)

    for _ in range(max_iter_bisection):

        # The desired accuracy fault_approx_pars.abstol_bisection has been met for the mean: we are done and return
        # to the calling function.
        if norm_dist < 2.0*abstol_bisection:

            # Add points to the list of surface points and return. Note that both points are in different classes.
            finished = True
            return point_left, point_right, finished
        else:

            # new midpoint
            point_mid = 0.5 * (point_left + point_right)

            # The interval length is halved.
            norm_dist = 0.5*norm_dist

            class_mid = compute_classification(point_mid.reshape(1, -1), problem_descr)

            # Same class as left point: fault line crosses the right part of the interval.
            if class_mid == class_left:
                point_left = point_mid
                class_left = class_mid

            # Same class as right point: fault line crosses the left part of the interval.
            elif class_mid == class_right:
                point_right = point_mid
                class_right = class_mid

            # This case indicates that there are at least two sections with fault lines on the line from left to right.
            # We skip the search in this case and return to the calling function.
            else:
                warn_message = f"Bisection in single_triplet_by_bisection failed, res = " \
                               f"{norm_dist} due to a third class {class_mid}."
                warn(warn_message)
                return point_left, point_right, finished

    warn_message = f"Bisection in single_triplet_by_bisection failed, res = " \
                   f"{norm_dist}, consider enlarging {max_iter_bisection}."
    warn(warn_message)
    return point_left, point_right, finished


def test_all_functions():
    from tests.test_funcs.TestFunc2D import func_fd_2d_cl3_c0_01

    points_left = np.array([[0.5, 0.5]])
    points_right = np.array([[0.5, 0.6]])

    classes_left = np.array([1], dtype=int)
    classes_right = np.array([1], dtype=int)
    i_class = 0
    j_class = 1
    problem_descr = ProblemDescr()
    problem_descr.test_func = func_fd_2d_cl3_c0_01
    problem_descr.x_min = np.array([0, 0])
    problem_descr.x_max = np.array([1, 1])

    result = start_pairs(points_left, points_right, classes_left, classes_right, i_class,
                         j_class, problem_descr)
    return result


if __name__ == '__main__':
    result_of_tests = test_all_functions()
